\section{Modelos de consistencia}

% Explicación de los modelos de consistencia en general.

En general, el objetivo de los \emph{mundos virtuales} es crear la ilusión un grupo de usuarios de que están viendo e interactuando con una misma realidad consistente, esto se llama \emph{state melding} y consiste principalmente en mantener la \emph{consistencia} y diseminar las actualizaciones a los procesos participantes \cite{liu2012survey}. La \textbf{consistencia} se entiende cómo la capacidad de encontrar el orden correcto de las operaciones que dependen entre sí, para mostrar un estado similar a todos los clientes.

Entre los métodos que han surgido para resolver esta problemática, es emblemático el de los relojes lógicos de L. Lamport \cite{lamport1978time}. Éste último y sus derivados están enfocados en problemas \textbf{discretos}, garantizando que la secuencia correcta de eventos haya sido propagada entre los participantes resultando en un estado coherente entre ellos.

Sin embargo, los videojuegos se tratan de problemas \textbf{continuos} en que los cambios de estado no dependen sólo de eventos sino también del transcurrir del tiempo. A parte de las relaciones de \emph{causalidad} señaladas por Lamport, se agregan las nociones de \emph{concurencia} y \emph{simultaneidad} \cite{liu2012survey}. No siendo una opción detener la ejecución a la espera de un evento, ya que se requiere que los resultados se vean reflejados como si los eventos hubieran sido ejecutadas en el punto que les corresponde en la línea temporal\cite{mauve2004local}.

Otra requerimiento de los videojuegos es la \textbf{responsividad}, que consiste en que el jugador sienta que sus acciones tienen efecto inmediato en el mundo del juego, osea que el tiempo de ejecución de sus eventos sean cercanos al momento en que son emitidos. Ante los retrasos de la red, la consistencia y la responsividad son objetivos encontrados, hacer que los retrasos no afecten a uno implica que tengan que afectar al otro.

Los modelos de consistencia son una formalización de los requisitos de consistencia que puede tener un sistema, \cite{liu2012survey} separa los modelos de consistencia en dos grupos, \emph{dead-line based consistency} y \emph{ultimate consistency}, en los primeros la consistencia respecto a un evento ocurrido en un momento $t$ se logra un un momento $t+\Delta$, mientras que en los segundos toma una cantidad indeterminada de tiempo ya que no necesariamente se fija el mismo tiempo de ejecución (en un reloj universal) en todos los clientes para cada evento, sólo imponiendo ciertas reglas de orden entre estos eventos. Diferentes mundos virtuales tienen diferentes requerimientos de consistencia, he ahí la necesidad de diferentes modelos de consistencia. A continuación se señalan los modelos recopilados por \cite{liu2012survey}.

\subsection{Modelos de \emph{ultimate consistency}}

\paragraph{Causal consistency} Requiere que todos los eventos relacionados causalmente sean percibidos en el mismo orden por los procesos, permitiendo que las operaciones concurrentes no relacionadas se puedan recibir y ejecutar en cualquier órden \cite{lamport1978time}.

\paragraph{Sequential consistency} Requiere que el resultado de cualquier ejecución sea el mismo que el que se hubiera dado si las operaciones fueran ejecutados en un orden secuencial consistente con el orden visto en por proceso individual \cite{lamport1979make}.
% TODO: Leer para explicarlo mejor?

\paragraph{Serializability} Es una extesión de la \emph{sequential consistency} que permite asegurar la ejecución atómica de instrucciones más complejas que lectura y escritura \cite{bernstein1987rrency}.

\subsection{Modelos \emph{dead-line based}}

\subsubsection{Perceptive consistency}

Señalada en \cite{bouillot2005fast}, se basa en que se cumplan dos propiedades, la primera es $\Delta$ \emph{legality} y la otra es \emph{simultaneity}.

La $\Delta$ \emph{legality} se puede entender como que la diferencia de tiempo entre que se ejecuta cualquier par de eventos en cualquier cliente que los recibe es la misma que la diferencia de tiempo entre que se emiten en su origen. Mientras que la \emph{simultaneity} se puede entender como que la diferencia de tiempo entre que se ejecuta cualquier par de eventos que se tome es la misma para todos los clientes.

Este tipo de consistencia equivaldría, en el contexto multimedia, a que todos los clientes vean una misma película, permitiendo que algunos la vean desfasados respecto a otros.

\subsubsection{Delayed consistency}

Es una relajación de la \emph{perceptive consistency}, que ejecuta los eventos originados localmente de manera inmediata en su tiempo $t$ y en los otros clientes se ejecutan en un tiempo $t+\Delta_{ij}$ donde $\Delta_{ij}$ es fijo y depende de cada par de clientes \cite{qin2002delayed}.

\subsubsection{Timed consistency}

Semejante a los modelos de \emph{ultimate consistency}, aseguran un límite $t+\Delta$ al tiempo de ejecución de un evento, incluyendo la \emph{timed sequential consistency} y la \emph{timed causal consistency} (versiones de la \emph{sequential consistency} y la \emph{causal consistency} que agregan este límite $t+\Delta$) \cite{torres1999timed}.

\subsection{Requerimientos de consistencia para juegos multijugador online}

Adicionalmente a estos modelos de consistencia, \cite{palant2006consistency} señala posibles \emph{requisitos de consistencia}, más complicados de formalizar, pero esperables en un videojuego.


% Explicar los presentados en los papers vistos.

% TODO: Explicar más modelos de consistencia faltantes.

% \subsubsection{Continuous consistency}

% TODO: Releer paper y colocar aquí.
% NOTE: Colocarlo antes o después de perceptive coonsistency?


% Todo esto tiene que ver con \cite{bouillot2005fast}


% Time-Sensitive Distributed Multiplayer Games son los que requieren que el usuario interactúe con su propia "réplica" local del juego (responsividad máxima), cada réplica ejecuta las actualizaciones en el mismo órden.

% El tiempo físico entre la ejecución de dos actualizaciones es el mismo para todos los usuarios, (simultaneity si las actualizaciones vienen de 2 fuentes diferetes y \Delta legality si vienen del mismo source.

% Dead Reckoning se basa en recibir los objetos de otro host y computar el estado actual que debería tener de acuerdo a la información de avance (posición,velocidad,etc.),

% Señalar que como los modelos ultimate consistency están bien estudiados, se usan y se aplican técnicas como dead reckoning para manejar las inconsistencias.
