\section{Conclusiones}

Respecto a las arquitecturas, \emph{peer-to-peer} con \emph{router} parece ser el más escalable de todos, quedó claro que el las arquitecturas \emph{simulator-centric} tienen un límite, aunque si en el mundo virtual que se quiere lograr es factible crear islas de objetos (y jugadores) o lograr un buen \emph{interest management} que \emph{granule} de manera abrupta los datos y el procesamiento, por razones de simpleza conviene usar \emph{simulator-centric}. En general los protocolos \emph{peer-to-peer} enfrentan desafíos de seguridad mucho mayores pues tienen que confiar en los clientes, pero el aplicar un \emph{router} resuelve este problema de seguridad y también el de a consistencia.

En los \emph{papers} investigados, no se encontraron sugerencias de métodos de interpolación en la visualización que permitan mostrar al jugador las inconsistencias de manera más suavizada, sin embargo parece lógico que esto debería realizarse (aunque los nuevos estados computados no se muestren de manera inmediata). En \cite{li2004supporting} las inconsistencias se muestran interpoladas aunque esto es el resultado del protocolo más que una técnica separada. Otro técnica paralela que podría ser necesario de usar, dependiendo del tipo de simulación, es separar los cambios \emph{duros} de los \emph{suaves}, siendo los primeros cosas significativas para el jugador, como la muerte de su ávatar o el cambio en el puntaje, estos cambios no deberían revertirse por lo que, dentro de lo posible, sólo deberían notificarse cuando ha pasado un tiempo de confirmación.

Se concluye que los protocolos se puede adaptar a casi cualquier arquitectura, pues se encargan de tratar la comunicación entre cada par de clientes y el manejo de la información local, mientras que el de las arquitecturas se preocupan de qué nodos conectar y que infraestructura de apoyo brindar, por ejemplo el protocolo con \emph{dead-reckoning} se puede implementar en una arquitecture \emph{peer-to-peer} si uno de los clientes actúa como servidor. Aun así, hay que considerar de la combinación que se está ocupando si esto refuerza los cuellos de botella de procesamiento y uso de la red, así como tener las consideraciones de seguridad correspondientes, intentado evitar responsabilizar a los clientes de otra cosa que sus eventos, de otra manera habría que añadir mecanismos de detección de trampas. De hecho, arquitecturas más avanzadas usan diferentes protocolos en conjunto para conjuntos de objetos o eventos que tienen requisitos diferentes.

% Aunque el trabajo original indica que se puede usar \emph{dead-reckoning} para hacer aparentemente más responsivo la simulación, esto no es posible sin lograr inconsistencias a nivel local, por lo que se requeriría, por ejemplo, algún método de interpolación para \emph{suavizar} la percepción de estas inconsistencias -> ojo, pero esto rompería el que se cumplan las reglas físicas en ciertos casos de mucha discrepancia. señalar que \cite{li2004supporting} hace esto (aunque no se programó).


% Concluír cosas...
%
% E.g.:
% - Qué protocolos son más convenientes para qué arquitecturas.
% - Qué protocolos y arquitecturas son mejores para qué tipo de juego (considerar por ejempo la cantidad de jugadores, la reactividad necesaria, cómputo necesario, consistencia, etc.).
% - Qué tecnologías se pueden utilizar para prevenir problemas de seguridad de los protocolos que los tienen.
% - ¿Algunas conclusiones sobre descentralización?
% - Qué cosas se podrían investigar más.
% - ... ¡Y muchas más!



% Hay una diferencia entre hacer dead reckoning con objetos manejados por cada usuario a hacerlo con eventos... elaborate more.

% Local lag en el cliente, local lag en el servidor, servidor resuelve el problema de seguridad de que los clientes pueden mentir respecto al local lag.

% Eventos "suaves" y eventos "duros", ¿En qué paper leí eso? ¿El de TSS?

% Aunque el trabajo original indica que se puede usar \emph{dead-reckoning} para hacer aparentemente más responsivo la simulación, esto no es posible sin lograr inconsistencias a nivel local, por lo que se requeriría, por ejemplo, algún método de interpolación para \emph{suavizar} la percepción de estas inconsistencias -> ojo, pero esto rompería el que se cumplan las reglas físicas en ciertos casos de mucha discrepancia. señalar que \cite{li2004supporting} hace esto (aunque no se programó).

% TODO: Agregar y revisitar conclusiones del informe de avance.

% El que la actualización de los estados respecto al tiempo sea determinsta es otra forma de evitar la necesidad de actualizaciones constantes y permitir otros modelos de consistencia, ¿Se convierte en una necesidad? <- Resolver esto.
% El problema es la lectura constante de la pantalla por parte del usuario final.

% Fenómenos de seguridad que pasan ante un usuario con percepción limitada, cómo se puede aprovechar.

% Importancia de los cambios "importantes", no se trató, el identificarlos, delay de confirmación, muchas otras cosas... (separar cambios importantes de cambios suceptibles a reparación).

% Temas de justicia, ¿Penalizar peores conexiones a la red?

% En los juegos coolaborativos se puede tolerar más las inconsistencias.

% Sistema híbrido no determinista en que haya comunicación p2p y un servidor con estados mandatorios para coordinar cada cierto tiempo.

% Arquitecturas más avanzadas combinan los métodos y protocolos, categorizando eventos según sus propiedades.

% Conclusion sobre (me olvidé)
